# MD0 (80 pts)

**Category:** Hash Functions — Length Extension
**Difficulty:** Medium

---

## Challenge

Server computes `MD5(data XOR FLAG)` where `data` can be any length (minimum FLAG length). Given: `MD5(FLAG) = known_hash`.

---

## Vulnerability

This is a **length extension attack** on MD5. MD5's Merkle-Damgård construction allows extending a hash without knowing the original message.

**Key insight:** When `data = FLAG`, the XOR produces zeros, and the server returns `MD5([0]*46)`. When we send data that XORs with FLAG to produce FLAG + padding + extension, we can verify the extended hash.

---

## Solution

```python
import hashpumpy

# Get the known MD5(FLAG)
md5_flag = "18f00c86a1f37473c719bc06935847ad"
flag_len = 46  # crypto{...} format

# Use hashpumpy to compute extension
# hashpump(known_hash, original_data, extension, original_len)
extended_hash, extended_msg = hashpumpy.hashpump(md5_flag, b"", b"A", flag_len)

# extended_msg contains: original || padding || extension
# We need to craft data such that data XOR cycle(FLAG) = extended_msg

# For MD0: data XOR FLAG = extended_msg
# So: data = extended_msg XOR FLAG (for known FLAG bytes)
```

**Attack steps:**
1. Query server with zeros to confirm hash computation
2. Use length extension to compute `MD5(FLAG || padding || extension)`
3. Craft input data that XORs to produce the extended message
4. Server returns the extended hash, confirming the attack

---

## Key Takeaway

**Length extension attacks exploit Merkle-Damgård's streaming property:** Given `H(m)` and `len(m)`, compute `H(m || pad || ext)` without knowing `m`. This breaks many "secret prefix" MAC constructions. Use HMAC instead of `H(secret || message)`.
